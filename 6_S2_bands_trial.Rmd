---
title: "Script to work with S2 bands derived from GEE"
subtitle: "Read and manipulation data, calculate indices"
author: "Alicia Valdés"
date: "`r format(Sys.time(), '%d %B %Y')`"
output:
  pdf_document: default
  html_notebook: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(warning = FALSE)
```

# Load libraries

```{r}
library(signal)
library(tidyverse)
library(here)
library(lubridate)
library(dtplyr)
library(sf)
library(knitr)
library(mgcv)
```

# Define printall function

```{r}
printall <- function(tibble) {
  print(tibble, width = Inf)
  }
```

# Read files

```{r}
trial <- read_csv("C:/Data/MOTIVATE/MOTIVATE_RS_data/S2/Bands/ALPATRA_S2_SR_HARMONIZED_RawBands_csPlus.csv")
```

# Some checks

Check that the year in the date of the images is not different to the sampling year:

```{r}
trial %>% filter(year != year(date))
```

Check how many different images are for each observation, date and time:

```{r}
trial %>% group_by(PlotObservationID, date, time_utc) %>%
  summarise(n_images = n_distinct(image_id), .groups = "drop") %>%
  count(n_images)
```

# Average the bands

When there is more than one image for each point and day, average the values of the bands:

```{r}
# Summarize the band values conditionally
band_summary <- trial %>%
  group_by(PlotObservationID, date) %>%
  summarise(
    n_images = n_distinct(image_id),
    B11 = if (n_images > 1) mean(B11, na.rm = TRUE) else first(B11),
    B2  = if (n_images > 1) mean(B2,  na.rm = TRUE) else first(B2),
    B3  = if (n_images > 1) mean(B3,  na.rm = TRUE) else first(B3),
    B4  = if (n_images > 1) mean(B4,  na.rm = TRUE) else first(B4),
    B8  = if (n_images > 1) mean(B8,  na.rm = TRUE) else first(B8),
    .groups = "drop"
  ) 

# Calculate how many different days for each PlotObservationID
n_days <- band_summary %>%
  group_by(PlotObservationID) %>%
  summarise(n_days = n_distinct(date))

# Join back to original data
trial_updated <- trial %>%
  # Remove old band values
  select(-B11, -B2, -B3, -B4, -B8) %>%
  # Join band_summary
  left_join(band_summary, by = c("PlotObservationID", "date")) %>%
  # Keep one row per group
  distinct(PlotObservationID, date, .keep_all = TRUE) %>%
  # Remove unwanted columns
  select(-`system:index`, -image_id, -.geo, -time_utc, -timestamp) %>%
  # Join
  left_join(n_days)
```

# Calculate indices and 5-day bins

```{r}
# Calculate indices
trial_indices <- trial_updated %>%
  # Set PlotObservationID as factor
  mutate(PlotObservationID = factor(PlotObservationID)) %>%
  # Rename the bands
  rename(blue = B2, green = B3, red = B4, NIR = B8, SWIR = B11) %>%
  # Scale the bands
  mutate(blue = blue / 10000, green = green / 10000, red = red / 10000,
         NIR = NIR / 10000, SWIR = SWIR / 10000) %>%
  # Create column that combines the day of the month and the time
  mutate(
    date = as.POSIXct(date),
    # Normalize the dates to a fixed year (2000)
    # so that seasonal patterns across different years can be compared visually
    day_month = as.POSIXct(format(date, "2000-%m-%d"))) %>%
  # Create column with DOY
  mutate(DOY = yday(date)) %>%
  # Calculate NDVI
  mutate(NDVI = (NIR - red) / (NIR + red),
         EVI = (NIR - red) * 2.5 / (NIR + 6 * red - 7.5 * blue + 1),
         SAVI = (NIR - red) * 1.5 / (NIR + red + 0.5),
         NDMI = (NIR - SWIR) / (NIR + SWIR),
         NDWI = (green - NIR) / (green + NIR)) %>%
  # Setting values of indices outside expected ranges (errors) to NA
  mutate(NDVI = if_else(NDVI > 1 | NDVI < -1, NA, NDVI),
         EVI = if_else(EVI > 1 | EVI < -1, NA, EVI), # 38 values of EVI as NA
         SAVI = if_else(EVI > 1 | SAVI < -1, NA, SAVI))
```

```{r}
trial_indices_binned <- trial_indices %>%
  mutate(DOY = yday(date),
         DOY_bin = floor(DOY / 5) * 5) %>% # 5-day bins
  # Bin NDVI into 5-day intervals
  group_by(PlotObservationID, DOY_bin) %>%
  # Mean composite
  summarise(NDVI = mean(NDVI, na.rm = TRUE), 
            EVI = mean(EVI, na.rm = TRUE),
            SAVI = mean(SAVI, na.rm = TRUE),
            NDMI = mean(NDMI, na.rm = TRUE),
            NDWI = mean(NDWI, na.rm = TRUE),
            .groups = "drop")
```

See the data:

```{r}
trial_indices %>% select(PlotObservationID, year, date, day_month, n_days,
                         EUNISa_1, EUNISa_1_descr,
                         blue, green, red, NIR, SWIR) %>%
  filter(PlotObservationID == 357179)
```

Plot n_daytime:

```{r}
trial_indices %>%
  group_by(PlotObservationID) %>%
  summarise(n_days = first(n_days)) %>% ungroup() %>%
  ggplot(aes(x = n_days)) + geom_histogram(color = "black", fill = "white") +
  theme_minimal()
```

# Time series plots

Plot time series:

```{r}
ggplot(trial_indices %>%
         filter(PlotObservationID == 357179 | PlotObservationID == 358127|
                PlotObservationID == 359289) %>%
         mutate(LegendLabel = paste(PlotObservationID, n_days, sep = ": ")), 
       aes(x = day_month, y = NDVI, color = LegendLabel)) +
  geom_line() + geom_point() +
  labs(x = "Day", y = "NDVI") +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1)
  )
ggplot(trial_indices %>%
         filter(EVI >= -1 & EVI <= 1) %>%
         filter(PlotObservationID == 357179 | PlotObservationID == 358127|
                PlotObservationID == 359289) %>%
         mutate(LegendLabel = paste(PlotObservationID, n_days, sep = ": ")), 
       aes(x = day_month, y = EVI, color = LegendLabel)) +
  geom_line() + geom_point() +
  labs(x = "Day", y = "EVI") +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1)
  )
ggplot(trial_indices %>%
         filter(SAVI >= -1 & SAVI <= 1) %>%
         filter(PlotObservationID == 357179 | PlotObservationID == 358127|
                PlotObservationID == 359289) %>%
         mutate(LegendLabel = paste(PlotObservationID, n_days, sep = ": ")), 
       aes(x = day_month, y = SAVI, color = LegendLabel)) +
  geom_line() + geom_point() +
  labs(x = "Day", y = "SAVI") +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1)
  )
ggplot(trial_indices %>%
         filter(PlotObservationID == 357179 | PlotObservationID == 358127|
                PlotObservationID == 359289) %>%
         mutate(LegendLabel = paste(PlotObservationID, n_days, sep = ": ")), 
       aes(x = day_month, y = NDMI, color = LegendLabel)) +
  geom_line() + geom_point() +
  labs(x = "Day", y = "NDMI") +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1)
  )
ggplot(trial_indices %>%
         filter(PlotObservationID == 357179 | PlotObservationID == 358127|
                PlotObservationID == 359289) %>%
         mutate(LegendLabel = paste(PlotObservationID, n_days, sep = ": ")), 
       aes(x = day_month, y = NDWI, color = LegendLabel)) +
  geom_line() + geom_point() +
  labs(x = "Day", y = "NDWI") +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1)
  )
```

Plot binned time series:

```{r}
ggplot(trial_indices_binned %>%
         filter(PlotObservationID == 357179 | PlotObservationID == 358127|
                PlotObservationID == 359289) %>%
         mutate(PlotObservationID), 
       aes(x = DOY_bin, y = NDVI, color = PlotObservationID)) +
  geom_line() + geom_point() +
  labs(x = "DOY bin", y = "NDVI") +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1)
  )
ggplot(trial_indices_binned %>%
         filter(EVI >= -1 & EVI <= 1) %>%
         filter(PlotObservationID == 357179 | PlotObservationID == 358127|
                PlotObservationID == 359289) %>%
         mutate(PlotObservationID), 
       aes(x = DOY_bin, y = EVI, color = PlotObservationID)) +
  geom_line() + geom_point() +
  labs(x = "DOY bin", y = "EVI") +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1)
  )
ggplot(trial_indices_binned %>%
         filter(SAVI >= -1 & EVI <= 1) %>%
         filter(PlotObservationID == 357179 | PlotObservationID == 358127|
                PlotObservationID == 359289) %>%
         mutate(PlotObservationID), 
       aes(x = DOY_bin, y = SAVI, color = PlotObservationID)) +
  geom_line() + geom_point() +
  labs(x = "DOY bin", y = "SAVI") +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1)
  )
ggplot(trial_indices_binned %>%
         filter(PlotObservationID == 357179 | PlotObservationID == 358127|
                PlotObservationID == 359289) %>%
         mutate(PlotObservationID), 
       aes(x = DOY_bin, y = NDMI, color = PlotObservationID)) +
  geom_line() + geom_point() +
  labs(x = "DOY bin", y = "NDMI") +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1)
  )
ggplot(trial_indices_binned %>%
         filter(PlotObservationID == 357179 | PlotObservationID == 358127|
                PlotObservationID == 359289) %>%
         mutate(PlotObservationID), 
       aes(x = DOY_bin, y = NDWI, color = PlotObservationID)) +
  geom_line() + geom_point() +
  labs(x = "DOY bin", y = "NDWI") +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1)
  )
```

# Compute phenological metrics from raw time series data

Functions to compute greening, browning and max DOY and NDVI / EVI / SAVI values:

```{r}
compute_metrics <- function(df) {
  # Arrange the data by DOY to ensure time series is in chronological order
  df <- df %>% arrange(DOY)
  
  df <- df %>%
    mutate(
      # Difference in NDVI between the current and previous day
      slope_ndvi = c(NA, diff(NDVI)),
      # Difference in NDVI between the current and next day
      slope_next_ndvi = c(diff(NDVI), NA),
      # Difference in EVI between the current and previous day
      slope_evi = c(NA, diff(EVI)),
      # Difference in EVI between the current and next day
      slope_next_evi = c(diff(EVI), NA),
      # Difference in SAVI between the current and previous day
      slope_savi = c(NA, diff(SAVI)),
      # Difference in SAVI between the current and next day
      slope_next_savi = c(diff(SAVI), NA)
      )
  
  # Greening: steepest positive slope
  greening_ndvi <- df %>%
    filter(slope_ndvi == max(slope_ndvi, na.rm = TRUE)) %>%
    slice(1)
  greening_evi <- df %>%
    filter(slope_evi == max(slope_evi, na.rm = TRUE)) %>%
    slice(1)
  greening_savi <- df %>%
    filter(slope_savi == max(slope_savi, na.rm = TRUE)) %>%
    slice(1)
  # Browning: steepest negative slope
  browning_ndvi <- df %>%
    filter(slope_next_ndvi == min(slope_next_ndvi, na.rm = TRUE)) %>%
    slice(1)
  browning_evi <- df %>%
    filter(slope_next_evi == min(slope_next_evi, na.rm = TRUE)) %>%
    slice(1)
  browning_savi <- df %>%
    filter(slope_next_savi == min(slope_next_savi, na.rm = TRUE))
  # Maximum NDVI
  max_ndvi <- df %>%
    filter(NDVI == max(NDVI, na.rm = TRUE)) %>%
    slice(1)
  max_evi <- df %>%
    filter(EVI == max(EVI, na.rm = TRUE)) %>%
    slice(1)
  max_savi <- df %>%
    filter(SAVI == max(SAVI, na.rm = TRUE)) %>%
    slice(1)
  
  # Return a tibble with everything
  tibble(
    greening_doy_ndvi = greening_ndvi$DOY,
    greening_ndvi = greening_ndvi$NDVI,
    browning_doy_ndvi = browning_ndvi$DOY,
    browning_ndvi = browning_ndvi$NDVI,
    max_ndvi_doy = max_ndvi$DOY,
    max_ndvi = max_ndvi$NDVI,
    greening_doy_evi = greening_evi$DOY,
    greening_evi = greening_evi$EVI,
    browning_doy_evi = browning_evi$DOY,
    browning_evi = browning_evi$EVI,
    max_evi_doy = max_evi$DOY,
    max_evi = max_evi$EVI,
    greening_doy_savi = greening_savi$DOY,
    greening_savi = greening_savi$SAVI,
    browning_doy_savi = browning_savi$DOY,
    browning_savi = browning_savi$SAVI,
    max_savi_doy = max_savi$DOY,
    max_savi = max_savi$SAVI
  )
  }

compute_metrics_binned <- function(df) {
  # Arrange the data by DOY_bin to ensure time series is in chronological order
  df <- df %>% arrange(DOY_bin)
  
  df <- df %>%
    mutate(
      # Difference in NDVI between the current and previous day
      slope_ndvi = c(NA, diff(NDVI)),
      # Difference in NDVI between the current and next day
      slope_next_ndvi = c(diff(NDVI), NA),
      # Difference in EVI between the current and previous day
      slope_evi = c(NA, diff(EVI)),
      # Difference in EVI between the current and next day
      slope_next_evi = c(diff(EVI), NA),
      # Difference in SAVI between the current and previous day
      slope_savi = c(NA, diff(SAVI)),
      # Difference in SAVI between the current and next day
      slope_next_savi = c(diff(SAVI), NA)
      )
  
  # Greening: steepest positive slope
  greening_ndvi <- df %>%
    filter(slope_ndvi == max(slope_ndvi, na.rm = TRUE)) %>%
    slice(1)
  greening_evi <- df %>%
    filter(slope_evi == max(slope_evi, na.rm = TRUE)) %>%
    slice(1)
  greening_savi <- df %>%
    filter(slope_savi == max(slope_savi, na.rm = TRUE)) %>%
    slice(1)
  # Browning: steepest negative slope
  browning_ndvi <- df %>%
    filter(slope_next_ndvi == min(slope_next_ndvi, na.rm = TRUE)) %>%
    slice(1)
  browning_evi <- df %>%
    filter(slope_next_evi == min(slope_next_evi, na.rm = TRUE)) %>%
    slice(1)
  browning_savi <- df %>%
    filter(slope_next_savi == min(slope_next_savi, na.rm = TRUE))
  # Maximum NDVI
  max_ndvi <- df %>%
    filter(NDVI == max(NDVI, na.rm = TRUE)) %>%
    slice(1)
  max_evi <- df %>%
    filter(EVI == max(EVI, na.rm = TRUE)) %>%
    slice(1)
  max_savi <- df %>%
    filter(SAVI == max(SAVI, na.rm = TRUE)) %>%
    slice(1)
  
  # Return a tibble with everything
  tibble(
    greening_doy_ndvi = greening_ndvi$DOY_bin,
    greening_ndvi = greening_ndvi$NDVI,
    browning_doy_ndvi = browning_ndvi$DOY_bin,
    browning_ndvi = browning_ndvi$NDVI,
    max_ndvi_doy = max_ndvi$DOY_bin,
    max_ndvi = max_ndvi$NDVI,
    greening_doy_evi = greening_evi$DOY_bin,
    greening_evi = greening_evi$EVI,
    browning_doy_evi = browning_evi$DOY_bin,
    browning_evi = browning_evi$EVI,
    max_evi_doy = max_evi$DOY_bin,
    max_evi = max_evi$EVI,
    greening_doy_savi = greening_savi$DOY_bin,
    greening_savi = greening_savi$SAVI,
    browning_doy_savi = browning_savi$DOY_bin,
    browning_savi = browning_savi$SAVI,
    max_savi_doy = max_savi$DOY_bin,
    max_savi = max_savi$SAVI
  )
  }
```

Apply the funcionts:

```{r}
# Apply to each PlotObservationID
phenology_metrics <- trial_indices %>%
  mutate(DOY = yday(date)) %>%
  group_by(PlotObservationID) %>%
  group_modify(~ compute_metrics(.x)) %>%
  ungroup()

phenology_metrics_binned <- trial_indices_binned %>%
  group_by(PlotObservationID) %>%
  group_modify(~ compute_metrics_binned(.x)) %>%
  ungroup()

# View results
print(phenology_metrics)
print(phenology_metrics_binned)
```

Join to indices:

```{r}
trial_indices_phen <- trial_indices %>%
  left_join(phenology_metrics)
trial_indices_phen_binned <- trial_indices_binned %>%
  left_join(phenology_metrics_binned)
```

## Plots

Plot time series with greening, browning and max:

```{r}
selected_ids <- c(357179, 358127, 359289)

ggplot(data = trial_indices_phen %>%
              filter(PlotObservationID %in% selected_ids)) +
  # NDVI lines and points
  geom_line(aes(x = DOY, y = NDVI, color = PlotObservationID)) +
  geom_point(aes(x = DOY, y = NDVI, color = PlotObservationID)) +
  # NDVI phenology points
  geom_point(aes(x = greening_doy_ndvi, y = greening_ndvi,
                 color = PlotObservationID), size = 4, shape = 17) +
  geom_point(aes(x = browning_doy_ndvi, y = browning_ndvi,
                 color = PlotObservationID), size = 4, shape = 15) +
  geom_point(aes(x = max_ndvi_doy, y = max_ndvi, color = PlotObservationID),
             size = 4, shape = 18) +
  labs(x = "Day of Year (DOY)", y = "Vegetation Index (NDVI)",
       title = "NDVI Time Series with Phenological Metrics") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

ggplot(data = trial_indices_phen %>%
              filter(PlotObservationID %in% selected_ids)) +
  # EVI lines and points
  geom_line(aes(x = DOY, y = EVI, color = PlotObservationID)) +
  geom_point(aes(x = DOY, y = EVI, color = PlotObservationID)) +
  # EVI phenology points
  geom_point(aes(x = greening_doy_evi, y = greening_evi,
                 color = PlotObservationID), size = 4, shape = 17) +
  geom_point(aes(x = browning_doy_evi, y = browning_evi,
                 color = PlotObservationID), size = 4, shape = 15) +
  geom_point(aes(x = max_evi_doy, y = max_evi, color = PlotObservationID),
             size = 4, shape = 18) +
  labs(x = "Day of Year (DOY)", y = "Vegetation Index (EVI)",
       title = "EVI Time Series with Phenological Metrics") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

ggplot(data = trial_indices_phen %>%
              filter(PlotObservationID %in% selected_ids)) +
  # SAVI lines and points
  geom_line(aes(x = DOY, y = SAVI, color = PlotObservationID)) +
  geom_point(aes(x = DOY, y = SAVI, color = PlotObservationID)) +
  # SAVI phenology points
  geom_point(aes(x = greening_doy_savi, y = greening_savi,
                 color = PlotObservationID), size = 4, shape = 17) +
  geom_point(aes(x = browning_doy_savi, y = browning_savi,
                 color = PlotObservationID), size = 4, shape = 15) +
  geom_point(aes(x = max_savi_doy, y = max_savi, color = PlotObservationID),
             size = 4, shape = 18) +
  labs(x = "Day of Year (DOY)", y = "Vegetation Index (SAVI)",
       title = "SAVI Time Series with Phenological Metrics") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

Plot binned time series with greening, browning and max:

```{r}
selected_ids <- c(357179, 358127, 359289)

ggplot(data = trial_indices_phen_binned %>%
              filter(PlotObservationID %in% selected_ids)) +
  # NDVI lines and points
  geom_line(aes(x = DOY_bin, y = NDVI, color = PlotObservationID)) +
  geom_point(aes(x = DOY_bin, y = NDVI, color = PlotObservationID)) +
  # NDVI phenology points
  geom_point(aes(x = greening_doy_ndvi, y = greening_ndvi,
                 color = PlotObservationID), size = 4, shape = 17) +
  geom_point(aes(x = browning_doy_ndvi, y = browning_ndvi,
                 color = PlotObservationID), size = 4, shape = 15) +
  geom_point(aes(x = max_ndvi_doy, y = max_ndvi, color = PlotObservationID),
             size = 4, shape = 18) +
  labs(x = "Day of Year (DOY)", y = "Vegetation Index (NDVI)",
       title = "NDVI Time Series with Phenological Metrics") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

ggplot(data = trial_indices_phen_binned %>%
         filter(PlotObservationID %in% selected_ids)) +
  # EVI lines and points
  geom_line(aes(x = DOY_bin, y = EVI, color = PlotObservationID)) +
  geom_point(aes(x = DOY_bin, y = EVI, color = PlotObservationID)) +
  # EVI phenology points
  geom_point(aes(x = greening_doy_evi, y = greening_evi,
                 color = PlotObservationID), size = 4, shape = 17) +
  geom_point(aes(x = browning_doy_evi, y = browning_evi,
                 color = PlotObservationID), size = 4, shape = 15) +
  geom_point(aes(x = max_evi_doy, y = max_evi, color = PlotObservationID),
             size = 4, shape = 18) +
  labs(x = "Day of Year (DOY)", y = "Vegetation Index (EVI)",
       title = "EVI Time Series with Phenological Metrics") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

ggplot(data = trial_indices_phen_binned %>%
         filter(PlotObservationID %in% selected_ids)) +
  # SAVI lines and points
  geom_line(aes(x = DOY_bin, y = SAVI, color = PlotObservationID)) +
  geom_point(aes(x = DOY_bin, y = SAVI, color = PlotObservationID)) +
  # SAVI phenology points
  geom_point(aes(x = greening_doy_savi, y = greening_savi,
                 color = PlotObservationID), size = 4, shape = 17) +
  geom_point(aes(x = browning_doy_savi, y = browning_savi,
                 color = PlotObservationID), size = 4, shape = 15) +
  geom_point(aes(x = max_savi_doy, y = max_savi, color = PlotObservationID),
             size = 4, shape = 18) +
  labs(x = "Day of Year (DOY)", y = "Vegetation Index (SAVI)",
       title = "SAVI Time Series with Phenological Metrics") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

# Compute phenological metrics from models fitted to time series data

## GAMs

Approach similar to https://doi.org/10.1016/j.jag.2020.102172.

Define function to compute phenology metrics using GAM fit and NDVI / EVI / SAVI:

```{r}
compute_metrics_models <- function(
    # Data frame df with index values over time (DOY)
  df, 
  # Name of the vegetation indices columns (e.g., "NDVI", "EVI", "SAVI)
  index_cols = c("NDVI", "EVI", "SAVI"),
  # Number of iterations for the reweighting process to refine the GAM fit
  max_iter = 3
  ) {
  # Initialize lists to store results
  metrics_list <- list()
  fits_list <- list()
  
  # Loop over each index column
  for (index_col in index_cols) {
    # Remove rows with missing index values and sort data by DOY
    df_index <- df %>% filter(!is.na(.data[[index_col]])) %>% arrange(DOY)
    
    # Replace values in DOY 1–50 and DOY 315–end with separate base values
    base_value_early <- mean(df_index %>% filter(DOY >= 1 & DOY <= 50) %>%
                               pull(index_col), na.rm = TRUE)
    base_value_late  <- mean(df_index %>% filter(DOY >= 315) %>%
                               pull(index_col), na.rm = TRUE)
    
    df_index <- df_index %>%
      mutate(!!index_col := case_when(
        DOY <= 50 ~ base_value_early,
        DOY >= 315 ~ base_value_late,
        TRUE ~ .data[[index_col]]
      ))
    
    # Extract x (DOY) and y (index) vectors for modelling
    x <- df_index$DOY
    y <- df_index[[index_col]]
    
    # If there are fewer than 11 observations or all values are NA, skip
    if (length(x) < 11 || all(is.na(y))) {
      next
    }
    
    # Create tibble to store original and predicted index values
    fits_df <- tibble(DOY = x, observed = y)
    
    # Fit initial GAM (unweighted):
    # Fit a GAM with a thin plate spline (bs = "tp") to smooth the index curve
    gam_unweighted <- gam(y ~ s(x, bs = "tp"))
    # Store the predicted values in the unweighted column
    fits_df$unweighted <- predict(gam_unweighted, newdata = tibble(x = x))
    
    # Iterative reweighted GAM fitting
    weights <- rep(1, length(y)) # Start with equal weights
    for (i in 1:max_iter) {
      # Update prediction and recalculate weights to emphasize
      # points where observed index is higher than predicted
      gam_fit <- gam(y ~ s(x, bs = "tp"), weights = weights)
      pred <- predict(gam_fit, newdata = tibble(x = x))
      if (any(is.na(pred))) {
        print(paste("Warning: NA predctions in iteration", i, "for", index_col))
        }
      fits_df[[paste0("iter_", i)]] <- pred
      
      # Apply weighting only between DOY 50 and 315
      weights <- rep(1, length(y))
      idx_between <- which(x > 50 & x < 315 & !is.na(pred) & pred != 0)
      weights[idx_between] <- (y[idx_between] / pred[idx_between])^4
      weights[weights > 1] <- 1
      weights[is.na(weights)] <- 1
    }
    
    # Compute phenological metrics for each fit_type
    fit_types <- c("unweighted", paste0("iter_", 1:max_iter))
    for (fit_type in fit_types) {
      pred <- fits_df[[fit_type]]
      
      if (all(is.na(pred))) {
        print(paste("All predictions are NA for", fit_type, "on", index_col))
      }
      
      slope <- c(NA, diff(pred))
      
      pos <- {
        idx <- which(x >= 50 & x <= 315)
        if (length(idx) > 0) x[idx][which.max(pred[idx])] else NA_real_
      }
      
      if (is.na(pos)) {
        print(paste("POS is NA for", fit_type, "on", index_col))
      }
      
      sos <- {
        idx <- which(x < pos)
        if (length(idx) > 0) {
          sub_x <- x[idx]
          sub_slope <- slope[idx]
          sub_x[which.max(sub_slope)]
        } else NA_real_
      }
      
      eos <- {
        idx <- which(x > pos)
        if (length(idx) > 0) {
          sub_x <- x[idx]
          sub_slope <- slope[idx]
          sub_x[which.min(sub_slope)]
        } else NA_real_
      }
      
      metrics_list[[paste(index_col, fit_type, sep = "_")]] <- tibble(
        PlotObservationID = unique(df$PlotObservationID),
        index = index_col,
        fit_type = fit_type,
        sos = sos,
        pos = pos,
        eos = eos
      )
      }

    # Store fits in long format
    fits_long <- fits_df %>%
      pivot_longer(cols = -DOY, names_to = "fit_type", values_to = "value") %>%
      mutate(
        PlotObservationID = unique(df$PlotObservationID),
        index = index_col
      )
    
    fits_list[[index_col]] <- fits_long
  }
  
  # Fallback in case no metrics were computed
  if (length(metrics_list) == 0) {
    print(paste("No metrics computed for PlotObservationID:",
                unique(df$PlotObservationID)))
    return(list(
      metrics_df = tibble(),
      fits_df = tibble()
    ))
  }
  
  # Combine metrics and fits into a single GAM_data tibble
  metrics_df <- bind_rows(metrics_list[!sapply(metrics_list, is.null)])
  fits_df <- bind_rows(fits_list)
  
  GAM_data <- fits_df %>%
    left_join(metrics_df, by = c("PlotObservationID", "index", "fit_type")) %>%
  mutate(method = "GAM") %>%
  # Specify column order
  select(PlotObservationID, DOY, method, fit_type, index, value, sos, pos, eos)
  
  # Return the combined tibble
  return(GAM_data)
  }
```

Apply the function:

```{r}
# Apply the function to each PlotObservationID
GAM_data <- trial_indices %>%
  group_split(PlotObservationID) %>%
  set_names(map_chr(., ~ as.character(unique(.x$PlotObservationID)))) %>%
  map_dfr(~ compute_metrics_models(df = .,
                                   index_cols = c("NDVI", "EVI", "SAVI")))
```

## Savitzky-Golay filtering

Define a function that applies Savitzky-Golay filtering only when the number of observatins in the group is greater or equal to the window size:

```{r}
safe_sgolay <- function(x, p, n) {
  # Find the indices of all non-NA values,
  # this ensures that we only apply the filter to valid data
  valid_idx <- which(!is.na(x))
  # Extract the non-NA values from x using the indices found above
  x_valid <- x[valid_idx]
  # Check if there are enough valid values to apply the filter
  # (at least n values)
  if (length(x_valid) >= n) {
    # Apply Savitzky-Golay filter to the valid values
    # using the specified polynomial order p and window size n
    smoothed <- sgolayfilt(x_valid, p = p, n = n)
    # Create a result vector of the same length as x, filled with NAs
    result <- rep(NA_real_, length(x))
    # Insert the smoothed values back into their original positions in the
    # results vector, leaving NAs where the original data was missing
    result[valid_idx] <- smoothed
    # Return the final smoothed vector
    return(result)
    # If there are not enough valid values, return a vector of NAs
    # of the same length as x
  } else {
    return(rep(NA_real_, length(x)))
  }
}
```

Apply the function:

```{r}
SG_data <- trial_indices %>%
  arrange(PlotObservationID, DOY) %>%
  group_by(PlotObservationID) %>%
  mutate(
    NDVI_sg_5  = safe_sgolay(NDVI, p = 2, n = 5),
    NDVI_sg_11 = safe_sgolay(NDVI, p = 2, n = 11),
    NDVI_sg_15 = safe_sgolay(NDVI, p = 2, n = 15),
    EVI_sg_5   = safe_sgolay(EVI, p = 2, n = 5),
    EVI_sg_11  = safe_sgolay(EVI, p = 2, n = 11),
    EVI_sg_15  = safe_sgolay(EVI, p = 2, n = 15),
    SAVI_sg_5   = safe_sgolay(SAVI, p = 2, n = 5),
    SAVI_sg_11  = safe_sgolay(SAVI, p = 2, n = 11),
    SAVI_sg_15  = safe_sgolay(SAVI, p = 2, n = 15)
  ) %>%
  ungroup()
```

```{r}
SG_data <- SG_data %>%
  select(DOY, PlotObservationID, NDVI, EVI, SAVI,
         NDVI_sg_5, NDVI_sg_11, NDVI_sg_15,
         EVI_sg_5, EVI_sg_11, EVI_sg_15,
         SAVI_sg_5, SAVI_sg_11, SAVI_sg_15) %>%
  pivot_longer(cols = -c(DOY, PlotObservationID),
               names_to = "variable", values_to = "value") %>%
  separate(variable, into = c("index", "fit_type"), 
           sep = "_sg_|(?<=NDVI|EVI|SAVI)(?=_sg_)", extra = "merge",
           fill = "right") %>%
  mutate(fit_type = ifelse(is.na(fit_type), "observed", paste0("sg_", fit_type)))
```

Calculate sos, pos and eos:

```{r}
phenology_metrics_SG <- SG_data %>%
  filter(fit_type != "observed") %>%
  group_by(PlotObservationID, index, fit_type) %>%
  arrange(DOY) %>%
  mutate(
    rate_of_change = c(NA, diff(value) / diff(DOY))
  ) %>%
  summarise(
    # Filter DOY range for POS
    pos = {
      pos_candidates <- DOY[DOY >= 50 & DOY <= 315]
      pos_values <- value[DOY >= 50 & DOY <= 315]
      if (length(pos_values) > 0) pos_candidates[which.max(pos_values)] else
        NA_real_
      },
    sos = {
      sos_candidates <- DOY[DOY < pos]
      roc_candidates <- rate_of_change[DOY < pos]
      if (length(roc_candidates) > 0) sos_candidates[which.max(roc_candidates)]
      else NA_real_
      },
    eos = {
      eos_candidates <- DOY[DOY > pos]
      roc_candidates <- rate_of_change[DOY > pos]
      if (length(roc_candidates) > 0) eos_candidates[which.min(roc_candidates)]
      else NA_real_
      },
    .groups = "drop")
```

Join:

```{r}
SG_data <- SG_data %>%
  left_join(phenology_metrics_SG) %>%
  mutate(method = "SG") %>%
  # Specify column order
  select(PlotObservationID, DOY, method, fit_type, index, value, sos, pos, eos)
```

## SG + GAM

First use SG as a preprocessing step to clean / reduce noise in the time series (reduce variability in index values). Them GAM for fitting a curve and extract phenogloical events using a derivative-based method.

Apply the GAM function to time series after applying SG filter (try with both 5 and 11 days):

```{r}
# Apply the function to each PlotObservationID
SG5_GAM_data <- SG_data %>% 
  select(PlotObservationID, DOY, fit_type, index, value) %>%
  filter(fit_type == "sg_5") %>%
  select(-fit_type) %>%
  pivot_wider(names_from = index, values_from = value) %>%
  group_split(PlotObservationID) %>%
  set_names(map_chr(., ~ as.character(unique(.x$PlotObservationID)))) %>%
  map_dfr(~ compute_metrics_models(df = .,
                                   index_cols = c("NDVI", "EVI", "SAVI"))) %>%
  # Change the name of the method
  mutate(method = "SG_GAM") %>%
  # Change the names of fit types
  mutate(fit_type = paste0("sg_5_", fit_type))
```

```{r}
# Apply the function to each PlotObservationID
SG11_GAM_data <- SG_data %>% 
  select(PlotObservationID, DOY, fit_type, index, value) %>%
  filter(fit_type == "sg_11") %>%
  select(-fit_type) %>%
  pivot_wider(names_from = index, values_from = value) %>%
  group_split(PlotObservationID) %>%
  set_names(map_chr(., ~ as.character(unique(.x$PlotObservationID)))) %>%
  map_dfr(~ compute_metrics_models(df = .,
                                   index_cols = c("NDVI", "EVI", "SAVI"))) %>%
  # Change the name of the method
  mutate(method = "SG_GAM") %>%
  # Change the names of fit types
  mutate(fit_type = paste0("sg_11_", fit_type))
```

## Tiblle with all methods

```{r}
all_methods_data <- bind_rows(GAM_data, SG_data, SG5_GAM_data, SG11_GAM_data)
```

## Plots comparing methods

```{r}
# Get unique PlotObservationIDs
unique_ids <- unique(all_methods_data$PlotObservationID)

# Create and store plots in a list
plots_all_methods <- map(unique_ids, function(id) {
  plot_data <- all_methods_data %>% filter(PlotObservationID == id) %>%
    mutate(fit_label = paste(method, fit_type, sep = " - ")) %>%
    mutate(fit_label = ifelse(fit_label == "SG - observed", "observed",
                              fit_label))
  
  ggplot(plot_data, aes(x = DOY, y = value, color = fit_label)) +
    # Raw data points
    geom_point(data = filter(plot_data,
                             method == "SG" & fit_type == "observed"),
               alpha = 0.5) +
    geom_line(data = filter(plot_data, fit_type == "unweighted" |
                              fit_type == "iter_3" | fit_type == "sg_11" |
                              fit_type == "sg_15" |
                              fit_type == "sg_5_iter_3" |
                              fit_type == "sg_11_iter_3"), size = 0.5) +
    geom_vline(data = filter(plot_data,
                             fit_type == "unweighted" | fit_type == "iter_3" |
                               fit_type == "sg_11" | fit_type == "sg_15" |
                               fit_type == "sg_5_iter_3" |
                               fit_type == "sg_11_iter_3"),
               aes(xintercept = sos, color = fit_label),
               linetype = "dashed", size = 0.5) +
    geom_vline(data = filter(plot_data,
                             fit_type == "unweighted" | fit_type == "iter_3" |
                               fit_type == "sg_11" | fit_type == "sg_15" |
                               fit_type == "sg_5_iter_3" |
                               fit_type == "sg_11_iter_3"),
               aes(xintercept = pos, color = fit_label),
               linetype = "dotted", size = 0.5) +
    geom_vline(data = filter(plot_data,
                             fit_type == "unweighted" | fit_type == "iter_3" |
                               fit_type == "sg_11" | fit_type == "sg_15" |
                               fit_type == "sg_5_iter_3" |
                               fit_type == "sg_11_iter_3"),
               aes(xintercept = eos, color = fit_label),
               linetype = "dashed", size = 0.5) +
    facet_grid(cols = vars(index)) +
    labs(
      title = glue::glue("PlotObservationID: {id}"),
      x = "Day of Year",
      y = "Index Value"
    ) +
    theme_minimal() + theme(legend.position = "top")
})

# Name the list by PlotObservationID
names(plots_all_methods) <- unique_ids

# Display the first plot
print(plots_all_methods[[1]])
```

Save each plot to a file:

```{r}
walk2(plots_all_methods, seq_along(plots_all_methods), ~ ggsave(
  filename = paste0("output/figures/phenology/plots_all_methods_", .y, ".jpeg"),
  plot = .x,
  width = 8,
  height = 5
))
```

## Compare NDVI-, EVI- and SAVI- derived metrics with different methods

```{r}
ggplot(all_methods_data %>%
         select(PlotObservationID, method, fit_type, index, sos, pos, eos) %>%
         filter(fit_type != "observed") %>%
         group_by(PlotObservationID, method, fit_type, index) %>%
         summarise(sos = first(sos), pos = first(pos), eos = first(eos),
                   .groups = "drop") %>%
         mutate(method_fit_type = paste(method, fit_type)) %>%
         pivot_longer(cols = c(sos, pos, eos),
                               names_to = "moment_type",
                               values_to = "value_moment"),
       aes(x = method_fit_type, y = value_moment, fill = method)) +
  facet_grid(cols = vars(moment_type), rows = vars(index)) +
  geom_boxplot() + theme_minimal() + theme(legend.position = "top") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

Scatterplots to compare EVI and NDVI:

```{r}
ggplot(all_methods_data %>%
         select(PlotObservationID, method, fit_type, index, sos, pos, eos) %>%
         filter(fit_type != "observed") %>%
         group_by(PlotObservationID, method, fit_type, index) %>%
         summarise(sos = first(sos), pos = first(pos), eos = first(eos),
                   .groups = "drop") %>%
         mutate(method_fit_type = paste(method, fit_type)) %>%
         pivot_longer(cols = c(sos, pos, eos),
                               names_to = "moment_type",
                               values_to = "value_moment") %>%
         pivot_wider(names_from = index, values_from = c(value_moment)),
       aes(x = EVI, y = NDVI, color = fit_type)) +
  geom_smooth(method = "lm", se = F) +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed") +
  facet_grid(cols = vars(moment_type), rows = vars(method))
```

Scatterplots to compare EVI and SAVI:

```{r}
ggplot(all_methods_data %>%
         select(PlotObservationID, method, fit_type, index, sos, pos, eos) %>%
         filter(fit_type != "observed") %>%
         group_by(PlotObservationID, method, fit_type, index) %>%
         summarise(sos = first(sos), pos = first(pos), eos = first(eos),
                   .groups = "drop") %>%
         mutate(method_fit_type = paste(method, fit_type)) %>%
         pivot_longer(cols = c(sos, pos, eos),
                               names_to = "moment_type",
                               values_to = "value_moment") %>%
         pivot_wider(names_from = index, values_from = c(value_moment)),
       aes(x = EVI, y = SAVI, color = fit_type)) +
  geom_smooth(method = "lm", se = F) +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed") +
  facet_grid(cols = vars(moment_type), rows = vars(method))
```

```{r}
ggplot(all_methods_data %>%
         select(PlotObservationID, method, fit_type, index, sos, pos, eos) %>%
         filter(fit_type != "observed") %>%
         filter(fit_type == "unweighted" | fit_type == "iter_3" |
                  fit_type == "sg_11" | fit_type == "sg_15" |
                  fit_type == "sg_5_iter_3" | fit_type == "sg_11_iter_3") %>%
         mutate(fit_label = paste(method, fit_type, sep = " - ")) %>%
         group_by(PlotObservationID, method, fit_label, index) %>%
         summarise(sos = first(sos), pos = first(pos), eos = first(eos),
                   .groups = "drop") %>%
         pivot_longer(cols = c(sos, pos, eos),
                               names_to = "moment_type",
                               values_to = "value_moment"),
       aes(x = value_moment, fill = index)) +
  geom_histogram(color = "black") +
  facet_grid(cols = vars(moment_type), rows = vars(fit_label))
```

```{r}
ggplot(all_methods_data %>%
         select(PlotObservationID, method, fit_type, index, sos, pos, eos) %>%
         filter(index == "EVI") %>%
         filter(fit_type != "observed") %>%
         filter(fit_type == "iter_3" |
                  fit_type == "sg_11" | fit_type == "sg_15" |
                  fit_type == "sg_5_iter_3" | fit_type == "sg_11_iter_3") %>%
         mutate(fit_label = paste(method, fit_type, sep = " - ")) %>%
         group_by(PlotObservationID, method, fit_label, index) %>%
         summarise(sos = first(sos), pos = first(pos), eos = first(eos),
                   .groups = "drop") %>%
         pivot_longer(cols = c(sos, pos, eos),
                               names_to = "moment_type",
                               values_to = "value_moment"),
       aes(x = value_moment)) +
  geom_histogram(color = "black") +
  facet_grid(cols = vars(moment_type), rows = vars(fit_label))
```

# USE: GAM iter_3 and NDVI / EVI

```{r}
GAM_data %>% filter(fit_type =="iter_3") %>%
  select(PlotObservationID, index, sos, pos, eos) %>% distinct() %>%
  pivot_longer(cols = c(sos, pos, eos),
               names_to = "moment", values_to = "value") %>%
  ggplot(aes(x = moment, y = value, fill = index)) + geom_boxplot() 
```

```{r}
# Get unique PlotObservationIDs
unique_ids <- unique(all_methods_data$PlotObservationID)

# Create and store plots in a list
plots_GAM_iter_3 <- map(unique_ids, function(id) {
  plot_data <- all_methods_data %>% filter(PlotObservationID == id) %>%
    mutate(fit_label = paste(method, fit_type, sep = " - ")) %>%
    mutate(fit_label = ifelse(fit_label == "SG - observed", "observed",
                              fit_label)) %>%
    filter(fit_label == "observed" | fit_label == "GAM - iter_3")
  
  ggplot(plot_data, aes(x = DOY, y = value, color = fit_label)) +
    # Raw data points
    geom_point(data = filter(plot_data,
                             method == "SG" & fit_type == "observed"),
               alpha = 0.5) +
    geom_line(data = filter(plot_data, fit_type == "unweighted" |
                              fit_type == "iter_3" | fit_type == "sg_11" |
                              fit_type == "sg_15" | fit_type == "iter_2" |
                              fit_type == "sg_5_iter_3" |
                              fit_type == "sg_11_iter_3"), size = 0.5) +
    geom_vline(data = filter(plot_data,
                             fit_type == "unweighted" | fit_type == "iter_3" |
                               fit_type == "sg_11" | fit_type == "sg_15" |
                               fit_type == "sg_5_iter_3" | fit_type == "iter_2" |
                               fit_type == "sg_11_iter_3"),
               aes(xintercept = sos, color = fit_label),
               linetype = "dashed", size = 0.5) +
    geom_vline(data = filter(plot_data,
                             fit_type == "unweighted" | fit_type == "iter_3" |
                               fit_type == "sg_11" | fit_type == "sg_15" |
                               fit_type == "sg_5_iter_3" | fit_type == "iter_2" |
                               fit_type == "sg_11_iter_3"),
               aes(xintercept = pos, color = fit_label),
               linetype = "dotted", size = 0.5) +
    geom_vline(data = filter(plot_data,
                             fit_type == "unweighted" | fit_type == "iter_3" |
                               fit_type == "sg_11" | fit_type == "sg_15" |
                               fit_type == "sg_5_iter_3" |
                               fit_type == "sg_11_iter_3"),
               aes(xintercept = eos, color = fit_label),
               linetype = "dashed", size = 0.5) +
    facet_grid(cols = vars(index)) +
    labs(
      title = glue::glue("PlotObservationID: {id}"),
      x = "Day of Year",
      y = "Index Value"
    ) +
    theme_minimal() + theme(legend.position = "top")
})

# Name the list by PlotObservationID
names(plots_GAM_iter_3) <- unique_ids

# Display the first plot
print(plots_GAM_iter_3[[1]])
```

Save each plot to a file:

```{r}
walk2(plots_GAM_iter_3, seq_along(plots_GAM_iter_3), ~ ggsave(
  filename = paste0("output/figures/phenology/plots_GAM_iter_3_", .y, ".jpeg"),
  plot = .x,
  width = 8,
  height = 5
))
```

# Smooth the time series of NDMI and NDWI

Using GAM, without replacing values in DOY 1–50 and DOY 315–end with separate base values, later use only unweighted GAM 

```{r}
compute_metrics_models_2 <- function(
    # Data frame df with index values over time (DOY)
  df, 
  # Name of the vegetation indices columns (e.g., "NDVI", "EVI", "SAVI)
  index_cols = c("NDMI", "NDWI"),
  # Number of iterations for the reweighting process to refine the GAM fit
  max_iter = 3
  ) {
  # Initialize lists to store results
  metrics_list <- list()
  fits_list <- list()
  
  # Loop over each index column
  for (index_col in index_cols) {
    # Remove rows with missing index values and sort data by DOY
    df_index <- df %>% filter(!is.na(.data[[index_col]])) %>% arrange(DOY)
    
    # Extract x (DOY) and y (index) vectors for modelling
    x <- df_index$DOY
    y <- df_index[[index_col]]
    
    # If there are fewer than 11 observations or all values are NA, skip
    if (length(x) < 11 || all(is.na(y))) {
      next
    }
    
    # Create tibble to store original and predicted index values
    fits_df <- tibble(DOY = x, observed = y)
    
    # Fit initial GAM (unweighted):
    # Fit a GAM with a thin plate spline (bs = "tp") to smooth the index curve
    gam_unweighted <- gam(y ~ s(x, bs = "tp"))
    # Store the predicted values in the unweighted column
    fits_df$unweighted <- predict(gam_unweighted, newdata = tibble(x = x))
    
    # Iterative reweighted GAM fitting
    weights <- rep(1, length(y)) # Start with equal weights
    for (i in 1:max_iter) {
      # Update prediction and recalculate weights to emphasize
      # points where observed index is higher than predicted
      gam_fit <- gam(y ~ s(x, bs = "tp"), weights = weights)
      pred <- predict(gam_fit, newdata = tibble(x = x))
      if (any(is.na(pred))) {
        print(paste("Warning: NA predctions in iteration", i, "for", index_col))
        }
      fits_df[[paste0("iter_", i)]] <- pred
      
      # Apply weighting only between DOY 50 and 315
      weights <- rep(1, length(y))
      idx_between <- which(x > 50 & x < 315 & !is.na(pred) & pred != 0)
      weights[idx_between] <- (y[idx_between] / pred[idx_between])^4
      weights[weights > 1] <- 1
      weights[is.na(weights)] <- 1
    }
    
    # Compute phenological metrics for each fit_type
    fit_types <- c("unweighted", paste0("iter_", 1:max_iter))
    for (fit_type in fit_types) {
      pred <- fits_df[[fit_type]]
      
      if (all(is.na(pred))) {
        print(paste("All predictions are NA for", fit_type, "on", index_col))
      }
      
      slope <- c(NA, diff(pred))
      
      pos <- {
        idx <- which(x >= 50 & x <= 315)
        if (length(idx) > 0) x[idx][which.max(pred[idx])] else NA_real_
      }
      
      if (is.na(pos)) {
        print(paste("POS is NA for", fit_type, "on", index_col))
      }
      
      sos <- {
        idx <- which(x < pos)
        if (length(idx) > 0) {
          sub_x <- x[idx]
          sub_slope <- slope[idx]
          sub_x[which.max(sub_slope)]
        } else NA_real_
      }
      
      eos <- {
        idx <- which(x > pos)
        if (length(idx) > 0) {
          sub_x <- x[idx]
          sub_slope <- slope[idx]
          sub_x[which.min(sub_slope)]
        } else NA_real_
      }
      
      metrics_list[[paste(index_col, fit_type, sep = "_")]] <- tibble(
        PlotObservationID = unique(df$PlotObservationID),
        index = index_col,
        fit_type = fit_type,
        sos = sos,
        pos = pos,
        eos = eos
      )
      }

    # Store fits in long format
    fits_long <- fits_df %>%
      pivot_longer(cols = -DOY, names_to = "fit_type", values_to = "value") %>%
      mutate(
        PlotObservationID = unique(df$PlotObservationID),
        index = index_col
      )
    
    fits_list[[index_col]] <- fits_long
  }
  
  # Fallback in case no metrics were computed
  if (length(metrics_list) == 0) {
    print(paste("No metrics computed for PlotObservationID:",
                unique(df$PlotObservationID)))
    return(list(
      metrics_df = tibble(),
      fits_df = tibble()
    ))
  }
  
  # Combine metrics and fits into a single GAM_data tibble
  metrics_df <- bind_rows(metrics_list[!sapply(metrics_list, is.null)])
  fits_df <- bind_rows(fits_list)
  
  GAM_data <- fits_df %>%
    left_join(metrics_df, by = c("PlotObservationID", "index", "fit_type")) %>%
  mutate(method = "GAM") %>%
  # Specify column order
  select(PlotObservationID, DOY, method, fit_type, index, value, sos, pos, eos)
  
  # Return the combined tibble
  return(GAM_data)
  }
```

Apply the function:

```{r}
# Apply the function to each PlotObservationID
smoothed_data <- trial_indices %>%
  group_split(PlotObservationID) %>%
  set_names(map_chr(., ~ as.character(unique(.x$PlotObservationID)))) %>%
  map_dfr(~ compute_metrics_models_2(df = .,
                                   index_cols = c("NDMI", "NDWI"))) %>%
  filter(fit_type == "unweighted") %>%
  select(PlotObservationID, DOY, index, value)
```

## Plots

```{r}
# Get unique PlotObservationIDs
unique_ids <- unique((trial_indices %>%
                        select(PlotObservationID, DOY, NDMI, NDWI) %>%
                        pivot_longer(cols = c(NDMI, NDWI), names_to = "index",
                                     values_to = "value"))$PlotObservationID)

# Create a named list of plots using purrr::map
plots_smoothed_data <- map(unique_ids, function(id) {
  ggplot() +
    geom_point(data = trial_indices %>%
                 select(PlotObservationID, DOY, NDMI, NDWI) %>%
                 pivot_longer(cols = c(NDMI, NDWI), names_to = "index",
                              values_to = "value") %>%
                 filter(PlotObservationID == id),
               aes(x = DOY, y = value), alpha = 0.6) +
    geom_line(data = smoothed_data %>% filter(PlotObservationID == id),
              aes(x = DOY, y = value), color = "blue") +
    facet_wrap(~ index) +
    labs(title = paste("PlotObservationID:", id)) +
    theme_minimal()
})

# Name the list by PlotObservationID
names(plots_smoothed_data) <- unique_ids

# Display the first plot
print(plots_smoothed_data[[1]])
```

Save each plot to a file:

```{r}
walk2(plots_smoothed_data, seq_along(plots_smoothed_data), ~ ggsave(
  filename = paste0("output/figures/phenology/plots_smoothed_data_", .y, ".jpeg"),
  plot = .x,
  width = 8,
  height = 5
))
```

# Get indices data (max. and min.)

Careful! These maximum and minimum values are from the smoothed time series. For NDVI / EVI / SAVI values in DOY 1–50 and DOY 315–end, remember that the GAM smoothing function replaced the original values with the mean base value of observations during each of these respective periods. This was so far not done for NDMI and NDWI. 

```{r}
final_indices_data <- GAM_data %>%
  # Filter for iter_3
  filter(fit_type =="iter_3") %>%
  select(-method, -fit_type) %>%
  group_by(PlotObservationID, index) %>%
  summarise(max = max(value), min = min(value)) %>%
  ungroup() %>%
  pivot_wider(names_from = index, values_from = c(max, min),
              names_glue = "{index}_{.value}") %>%
  full_join(
    smoothed_data %>%
      group_by(PlotObservationID, index) %>%
      summarise(max = max(value), min = min(value)) %>%
      ungroup() %>%
      pivot_wider(names_from = index, values_from = c(max, min),
                  names_glue = "{index}_{.value}")
    )
```

# Get phenology data

Use GAM iter_3 to get dates of the moments and values at those moments:

```{r}
# Join to get values at SOS, POS, EOS
final_phenology_data <- GAM_data %>%
  # Filter for iter_3 & discard SAVI
  filter(fit_type =="iter_3" & index != "SAVI") %>%
  select(-method, -fit_type) %>%
  mutate(
    stage = case_when(
      DOY == sos ~ "sos",
      DOY == pos ~ "pos",
      DOY == eos ~ "eos",
      TRUE ~ NA_character_
    )
  ) %>%
  filter(!is.na(stage)) %>%
  select(PlotObservationID, index, stage, doy = DOY, value) %>%
  pivot_wider(
    names_from = c(index, stage),
    values_from = c(doy, value),
    names_glue = "{index}_{stage}_{.value}"
  )
```

# Join indices and phenology data

```{r}
final_RS_data <- full_join(final_indices_data, final_phenology_data)
```

## Later: Calculate other metrics apart from sos, pos and eos

### HERE

In another notebook, do this with GAM iter_3 for all bioregions.

## DO? Harmonic Analysis of Time Series

## DO? Threshold method for getting sos, pos and eos

# Session info

```{r}
sessionInfo()
```

